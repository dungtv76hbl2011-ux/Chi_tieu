<script>
// ========================================
// ERROR HANDLER - CENTRALIZED ERROR RECOVERY
// ========================================

const ErrorHandler = (function() {
  'use strict';
  
  const MAX_RETRIES = 3;
  const RETRY_DELAY = 1000; // 1 second
  
  const errorLog = [];
  const retryQueue = [];
  
  // ========== API CALL WITH RETRY ==========
  
  async function callWithRetry(action, params, retries = MAX_RETRIES) {
    for (let attempt = 1; attempt <= retries; attempt++) {
      try {
        console.log(`üîÑ Attempt ${attempt}/${retries}: ${action}`);
        
        const result = await callAPI(action, params);
        
        if (result && result.success) {
          console.log(`‚úÖ Success: ${action}`);
          return result;
        } else {
          throw new Error(result?.message || 'Unknown error');
        }
        
      } catch (error) {
        console.error(`‚ùå Attempt ${attempt} failed:`, error);
        
        logError(action, params, error, attempt);
        
        if (attempt === retries) {
          // Final attempt failed
          handleFinalFailure(action, params, error);
          throw error;
        }
        
        // Wait before retry
        await sleep(RETRY_DELAY * attempt);
      }
    }
  }
  
  function callAPI(action, params) {
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('Request timeout'));
      }, 30000); // 30 seconds
      
      google.script.run
        .withSuccessHandler(response => {
          clearTimeout(timeout);
          resolve(response);
        })
        .withFailureHandler(error => {
          clearTimeout(timeout);
          reject(error);
        })
        .handleRequest(action, params);
    });
  }
  
  // ========== ERROR LOGGING ==========
  
  function logError(action, params, error, attempt) {
    const errorEntry = {
      timestamp: new Date().toISOString(),
      action,
      params,
      error: error.message,
      attempt,
      stack: error.stack
    };
    
    errorLog.push(errorEntry);
    
    // Keep only last 100 errors
    if (errorLog.length > 100) {
      errorLog.shift();
    }
    
    console.error('üìù Error logged:', errorEntry);
  }
  
  function handleFinalFailure(action, params, error) {
    // Add to retry queue for manual retry
    retryQueue.push({
      action,
      params,
      error: error.message,
      timestamp: Date.now()
    });
    
    // Show user-friendly error
    showToast(
      `L·ªói: ${getFriendlyErrorMessage(action, error)}`,
      'error'
    );
    
    // Offer manual retry
    if (retryQueue.length > 0) {
      showRetryNotification();
    }
  }
  
  // ========== USER-FRIENDLY MESSAGES ==========
  
  function getFriendlyErrorMessage(action, error) {
    const errorMessages = {
      'createRecord': 'Kh√¥ng th·ªÉ t·∫°o b·∫£n ghi. Vui l√≤ng th·ª≠ l·∫°i.',
      'updateRecord': 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t. Vui l√≤ng th·ª≠ l·∫°i.',
      'deleteRecord': 'Kh√¥ng th·ªÉ x√≥a. Vui l√≤ng th·ª≠ l·∫°i.',
      'getAllData': 'Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu. Vui l√≤ng l√†m m·ªõi trang.',
      'updateAccountBalance': 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t s·ªë d∆∞ t√†i kho·∫£n.',
      'calculateBudgetSpent': 'Kh√¥ng th·ªÉ t√≠nh to√°n ng√¢n s√°ch.',
      'login': 'ƒêƒÉng nh·∫≠p th·∫•t b·∫°i. Vui l√≤ng ki·ªÉm tra t√†i kho·∫£n.'
    };
    
    if (error.message && error.message.includes('timeout')) {
      return 'K·∫øt n·ªëi b·ªã gi√°n ƒëo·∫°n. Vui l√≤ng ki·ªÉm tra m·∫°ng.';
    }
    
    if (error.message && error.message.includes('Session')) {
      return 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.';
    }
    
    return errorMessages[action] || 'ƒê√£ x·∫£y ra l·ªói. Vui l√≤ng th·ª≠ l·∫°i.';
  }
  
  // ========== RETRY NOTIFICATION ==========
  
  function showRetryNotification() {
    const notification = document.createElement('div');
    notification.id = 'retryNotification';
    notification.style.cssText = `
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: #fff;
      border: 2px solid #f59e0b;
      border-radius: 8px;
      padding: 15px 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 10001;
      max-width: 300px;
    `;
    
    notification.innerHTML = `
      <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
        <i class="fas fa-exclamation-triangle" style="color: #f59e0b; font-size: 20px;"></i>
        <strong>C√≥ ${retryQueue.length} thao t√°c th·∫•t b·∫°i</strong>
      </div>
      <button onclick="ErrorHandler.retryAll()" class="btn-warning" style="width: 100%; padding: 8px;">
        <i class="fas fa-redo"></i> Th·ª≠ l·∫°i t·∫•t c·∫£
      </button>
      <button onclick="ErrorHandler.clearQueue()" class="btn-secondary" style="width: 100%; padding: 8px; margin-top: 5px;">
        <i class="fas fa-times"></i> B·ªè qua
      </button>
    `;
    
    // Remove old notification if exists
    const oldNotification = document.getElementById('retryNotification');
    if (oldNotification) {
      oldNotification.remove();
    }
    
    document.body.appendChild(notification);
  }
  
  // ========== RETRY QUEUE ==========
  
  async function retryAll() {
    const queue = [...retryQueue];
    retryQueue.length = 0; // Clear queue
    
    const notification = document.getElementById('retryNotification');
    if (notification) {
      notification.remove();
    }
    
    showLoading(`ƒêang th·ª≠ l·∫°i ${queue.length} thao t√°c...`);
    
    let successCount = 0;
    let failedCount = 0;
    
    for (const item of queue) {
      try {
        await callWithRetry(item.action, item.params, 2);
        successCount++;
      } catch (error) {
        failedCount++;
        retryQueue.push(item); // Re-add failed items
      }
    }
    
    hideLoading();
    
    if (successCount > 0) {
      showToast(`Th√†nh c√¥ng: ${successCount} thao t√°c`, 'success');
    }
    
    if (failedCount > 0) {
      showToast(`Th·∫•t b·∫°i: ${failedCount} thao t√°c`, 'error');
      showRetryNotification();
    }
  }
  
  function clearQueue() {
    retryQueue.length = 0;
    
    const notification = document.getElementById('retryNotification');
    if (notification) {
      notification.remove();
    }
    
    showToast('ƒê√£ x√≥a h√†ng ƒë·ª£i', 'info');
  }
  
  // ========== HELPERS ==========
  
  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  function getErrorLog() {
    return [...errorLog];
  }
  
  function getRetryQueue() {
    return [...retryQueue];
  }
  
  // ========== PUBLIC API ==========
  
  return {
    callWithRetry,
    retryAll,
    clearQueue,
    getErrorLog,
    getRetryQueue
  };
})();

// Test ErrorHandler
(async function testErrorHandler() {
  console.log('=== Testing ErrorHandler ===');
  
  // Test 1: Successful call
  try {
    var result = await ErrorHandler.callWithRetry('getSession', {});
    console.log('‚úì API call successful:', result.success);
  } catch (error) {
    console.error('‚úó API call failed:', error);
  }
  
  // Test 2: Error log
  var errorLog = ErrorHandler.getErrorLog();
  console.assert(Array.isArray(errorLog), 'getErrorLog should return array');
  console.log('‚úì Error log entries:', errorLog.length);
  
  console.log('‚úÖ ErrorHandler tests passed');
})();

</script>
